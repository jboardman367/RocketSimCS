// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace RocketSim
{
    public enum RocketSimStage : byte
    {
        UNINITIALIZED = 0,
        INITIALIZING = 1,
        INITIALIZED = 2
    }

    namespace RocketSim
    {
        public unsafe partial class RocketSim
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?StringInit@RocketSim@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void StringInit([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string collisionMeshesFolder);

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?AssertInitialized@RocketSim@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AssertInitialized([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string errorMsgPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetStage@RocketSim@@YA?AW4RocketSimStage@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::RocketSim.RocketSimStage GetStage();

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetDefaultSuspColGrid@RocketSim@@YAAEBUSuspensionCollisionGrid@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDefaultSuspColGrid();
            }

            public static void StringInit(string collisionMeshesFolder)
            {
                __Internal.StringInit(collisionMeshesFolder);
            }

            public static void AssertInitialized(string errorMsgPrefix)
            {
                __Internal.AssertInitialized(errorMsgPrefix);
            }

            public static global::RocketSim.RocketSimStage GetStage()
            {
                var ___ret = __Internal.GetStage();
                return ___ret;
            }

            public static global::RocketSim.SuspensionCollisionGrid GetDefaultSuspColGrid()
            {
                var ___ret = __Internal.GetDefaultSuspColGrid();
                var __result0 = global::RocketSim.SuspensionCollisionGrid.__GetOrCreateInstance(___ret, false);
                return __result0;
            }
        }
    }

    public unsafe partial class Framework
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?__RS_GET_VERSION_ID@@YAIXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint RS_GET_VERSION_ID();
        }

        public static uint RS_GET_VERSION_ID()
        {
            var ___ret = __Internal.RS_GET_VERSION_ID();
            return ___ret;
        }
    }

    public enum BT_USERINFO
    {
        BT_USERINFO_NONE = 0,
        BT_USERINFO_TYPE_CAR = 1,
        BT_USERINFO_TYPE_BALL = 2
    }

    public unsafe partial class Vec : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float x;
            internal float y;
            internal float z;
            internal float _w;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0Vec@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0Vec@@QEAA@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float x, float y, float z, float _w);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0Vec@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Dot@Vec@@QEBAMAEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Dot(__IntPtr __instance, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Cross@Vec@@QEBA?AU1@AEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Cross(__IntPtr __instance, __IntPtr @return, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?DistSq@Vec@@QEBAMAEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float DistSq(__IntPtr __instance, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Dist@Vec@@QEBAMAEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Dist(__IntPtr __instance, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?DistSq2D@Vec@@QEBAMAEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float DistSq2D(__IntPtr __instance, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Dist2D@Vec@@QEBAMAEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Dist2D(__IntPtr __instance, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??HVec@@QEBA?AU0@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorPlus(__IntPtr __instance, __IntPtr @return, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??DVec@@QEBA?AU0@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorStar(__IntPtr __instance, __IntPtr @return, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??KVec@@QEBA?AU0@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorSlash(__IntPtr __instance, __IntPtr @return, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??DVec@@QEBA?AU0@M@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorStar(__IntPtr __instance, __IntPtr @return, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??KVec@@QEBA?AU0@M@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorSlash(__IntPtr __instance, __IntPtr @return, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??MVec@@QEBA_NAEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(__IntPtr __instance, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??OVec@@QEBA_NAEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(__IntPtr __instance, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??GVec@@QEBA?AU0@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorMinus(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??AVec@@QEAAAEAMI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float* OperatorSubscript(__IntPtr __instance, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?IsZero@Vec@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsZero(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?LengthSq@Vec@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float LengthSq(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Length@Vec@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Length(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Normalized@Vec@@QEBA?AU1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Normalized(__IntPtr __instance, __IntPtr @return);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Vec> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Vec>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.Vec managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.Vec managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Vec __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Vec(native.ToPointer(), skipVTables);
        }

        internal static Vec __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Vec)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Vec __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Vec(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vec(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Vec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Vec()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Vec.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public Vec(float x, float y, float z, float _w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Vec.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, x, y, z, _w);
        }

        public Vec(global::RocketSim.Vec _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Vec.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.Vec.__Internal*) __Instance) = *((global::RocketSim.Vec.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Dot(global::RocketSim.Vec other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var ___ret = __Internal.Dot(__Instance, __arg0);
            return ___ret;
        }

        public global::RocketSim.Vec Cross(global::RocketSim.Vec other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.Cross(__Instance, new IntPtr(&___ret), __arg0);
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public float DistSq(global::RocketSim.Vec other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var ___ret = __Internal.DistSq(__Instance, __arg0);
            return ___ret;
        }

        public float Dist(global::RocketSim.Vec other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var ___ret = __Internal.Dist(__Instance, __arg0);
            return ___ret;
        }

        public float DistSq2D(global::RocketSim.Vec other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var ___ret = __Internal.DistSq2D(__Instance, __arg0);
            return ___ret;
        }

        public float Dist2D(global::RocketSim.Vec other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var ___ret = __Internal.Dist2D(__Instance, __arg0);
            return ___ret;
        }

        public static global::RocketSim.Vec operator +(global::RocketSim.Vec __op, global::RocketSim.Vec other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.OperatorPlus(__arg0, new IntPtr(&___ret), __arg1);
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public static global::RocketSim.Vec operator *(global::RocketSim.Vec __op, global::RocketSim.Vec other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.OperatorStar(__arg0, new IntPtr(&___ret), __arg1);
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public static global::RocketSim.Vec operator /(global::RocketSim.Vec __op, global::RocketSim.Vec other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.OperatorSlash(__arg0, new IntPtr(&___ret), __arg1);
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public static global::RocketSim.Vec operator *(global::RocketSim.Vec __op, float val)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.OperatorStar(__arg0, new IntPtr(&___ret), val);
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public static global::RocketSim.Vec operator /(global::RocketSim.Vec __op, float val)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.OperatorSlash(__arg0, new IntPtr(&___ret), val);
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public static bool operator <(global::RocketSim.Vec __op, global::RocketSim.Vec other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var ___ret = __Internal.OperatorLess(__arg0, __arg1);
            return ___ret;
        }

        public static bool operator >(global::RocketSim.Vec __op, global::RocketSim.Vec other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var ___ret = __Internal.OperatorGreater(__arg0, __arg1);
            return ___ret;
        }

        public static global::RocketSim.Vec operator -(global::RocketSim.Vec __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&___ret));
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public float this[uint index]
        {
            get
            {
                var ___ret = __Internal.OperatorSubscript(__Instance, index);
                return *___ret;
            }

            set
            {
                *global::RocketSim.Vec.__Internal.OperatorSubscript(__Instance, index) = value;
            }
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->z;
            }

            set
            {
                ((__Internal*)__Instance)->z = value;
            }
        }

        public float W
        {
            get
            {
                return ((__Internal*)__Instance)->_w;
            }

            set
            {
                ((__Internal*)__Instance)->_w = value;
            }
        }

        public bool IsZero
        {
            get
            {
                var ___ret = __Internal.IsZero(__Instance);
                return ___ret;
            }
        }

        public float LengthSq
        {
            get
            {
                var ___ret = __Internal.LengthSq(__Instance);
                return ___ret;
            }
        }

        public float Length
        {
            get
            {
                var ___ret = __Internal.Length(__Instance);
                return ___ret;
            }
        }

        public global::RocketSim.Vec Normalized
        {
            get
            {
                var ___ret = new global::RocketSim.Vec.__Internal();
                __Internal.Normalized(__Instance, new IntPtr(&___ret));
                return global::RocketSim.Vec.__CreateInstance(___ret);
            }
        }
    }

    public unsafe partial class RotMat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::RocketSim.Vec.__Internal forward;

            [FieldOffset(16)]
            internal global::RocketSim.Vec.__Internal right;

            [FieldOffset(32)]
            internal global::RocketSim.Vec.__Internal up;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0RotMat@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0RotMat@@QEAA@UVec@@00@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr forward, __IntPtr right, __IntPtr up);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0RotMat@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??HRotMat@@QEBA?AU0@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorPlus(__IntPtr __instance, __IntPtr @return, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??GRotMat@@QEBA?AU0@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorMinus(__IntPtr __instance, __IntPtr @return, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??DRotMat@@QEBA?AU0@M@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorStar(__IntPtr __instance, __IntPtr @return, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??KRotMat@@QEBA?AU0@M@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorSlash(__IntPtr __instance, __IntPtr @return, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Dot@RotMat@@QEBA?AUVec@@AEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Dot(__IntPtr __instance, __IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??ARotMat@@QEAAAEAUVec@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr OperatorSubscript(__IntPtr __instance, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetIdentity@RotMat@@SA?AU1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetIdentity(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Transpose@RotMat@@QEBA?AU1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Transpose(__IntPtr __instance, __IntPtr @return);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.RotMat> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.RotMat>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.RotMat managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.RotMat managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RotMat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RotMat(native.ToPointer(), skipVTables);
        }

        internal static RotMat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RotMat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RotMat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RotMat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RotMat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RotMat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RotMat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.RotMat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public RotMat(global::RocketSim.Vec forward, global::RocketSim.Vec right, global::RocketSim.Vec up)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.RotMat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(forward, null))
                throw new global::System.ArgumentNullException("forward", "Cannot be null because it is passed by value.");
            var __arg0 = forward.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is passed by value.");
            var __arg1 = right.__Instance;
            if (ReferenceEquals(up, null))
                throw new global::System.ArgumentNullException("up", "Cannot be null because it is passed by value.");
            var __arg2 = up.__Instance;
            __Internal.ctor(__Instance, __arg0, __arg1, __arg2);
        }

        public RotMat(global::RocketSim.RotMat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.RotMat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.RotMat.__Internal*) __Instance) = *((global::RocketSim.RotMat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static global::RocketSim.RotMat operator +(global::RocketSim.RotMat __op, global::RocketSim.RotMat other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var ___ret = new global::RocketSim.RotMat.__Internal();
            __Internal.OperatorPlus(__arg0, new IntPtr(&___ret), __arg1);
            return global::RocketSim.RotMat.__CreateInstance(___ret);
        }

        public static global::RocketSim.RotMat operator -(global::RocketSim.RotMat __op, global::RocketSim.RotMat other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var ___ret = new global::RocketSim.RotMat.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&___ret), __arg1);
            return global::RocketSim.RotMat.__CreateInstance(___ret);
        }

        public static global::RocketSim.RotMat operator *(global::RocketSim.RotMat __op, float val)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var ___ret = new global::RocketSim.RotMat.__Internal();
            __Internal.OperatorStar(__arg0, new IntPtr(&___ret), val);
            return global::RocketSim.RotMat.__CreateInstance(___ret);
        }

        public static global::RocketSim.RotMat operator /(global::RocketSim.RotMat __op, float val)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var ___ret = new global::RocketSim.RotMat.__Internal();
            __Internal.OperatorSlash(__arg0, new IntPtr(&___ret), val);
            return global::RocketSim.RotMat.__CreateInstance(___ret);
        }

        public global::RocketSim.Vec Dot(global::RocketSim.Vec vec)
        {
            if (ReferenceEquals(vec, null))
                throw new global::System.ArgumentNullException("vec", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = vec.__Instance;
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.Dot(__Instance, new IntPtr(&___ret), __arg0);
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public global::RocketSim.Vec this[uint index]
        {
            get
            {
                var ___ret = __Internal.OperatorSubscript(__Instance, index);
                var __result0 = global::RocketSim.Vec.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                *(global::RocketSim.Vec.__Internal*) global::RocketSim.RotMat.__Internal.OperatorSubscript(__Instance, index) = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec Forward
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->forward));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->forward = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec Right
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->right));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->right = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec Up
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->up));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->up = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public static global::RocketSim.RotMat Identity
        {
            get
            {
                var ___ret = new global::RocketSim.RotMat.__Internal();
                __Internal.GetIdentity(new IntPtr(&___ret));
                return global::RocketSim.RotMat.__CreateInstance(___ret);
            }
        }

        public global::RocketSim.RotMat Transpose
        {
            get
            {
                var ___ret = new global::RocketSim.RotMat.__Internal();
                __Internal.Transpose(__Instance, new IntPtr(&___ret));
                return global::RocketSim.RotMat.__CreateInstance(___ret);
            }
        }
    }

    public unsafe partial class Angle : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float yaw;
            internal float pitch;
            internal float roll;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0Angle@@QEAA@MMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float yaw, float pitch, float roll);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0Angle@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?FromRotMat@Angle@@SA?AU1@URotMat@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FromRotMat(__IntPtr @return, __IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?ToRotMat@Angle@@QEBA?AURotMat@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ToRotMat(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?NormalizeFix@Angle@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void NormalizeFix(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetForwardVector@Angle@@QEBA?AUVec@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetForwardVector(__IntPtr __instance, __IntPtr @return);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Angle> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Angle>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.Angle managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.Angle managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Angle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Angle(native.ToPointer(), skipVTables);
        }

        internal static Angle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Angle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Angle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Angle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Angle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Angle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Angle(float yaw, float pitch, float roll)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Angle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, yaw, pitch, roll);
        }

        public Angle(global::RocketSim.Angle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Angle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.Angle.__Internal*) __Instance) = *((global::RocketSim.Angle.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::RocketSim.RotMat ToRotMat()
        {
            var ___ret = new global::RocketSim.RotMat.__Internal();
            __Internal.ToRotMat(__Instance, new IntPtr(&___ret));
            return global::RocketSim.RotMat.__CreateInstance(___ret);
        }

        public void NormalizeFix()
        {
            __Internal.NormalizeFix(__Instance);
        }

        public static global::RocketSim.Angle FromRotMat(global::RocketSim.RotMat mat)
        {
            if (ReferenceEquals(mat, null))
                throw new global::System.ArgumentNullException("mat", "Cannot be null because it is passed by value.");
            var __arg0 = mat.__Instance;
            var ___ret = new global::RocketSim.Angle.__Internal();
            __Internal.FromRotMat(new IntPtr(&___ret), __arg0);
            return global::RocketSim.Angle.__CreateInstance(___ret);
        }

        public float Yaw
        {
            get
            {
                return ((__Internal*)__Instance)->yaw;
            }

            set
            {
                ((__Internal*)__Instance)->yaw = value;
            }
        }

        public float Pitch
        {
            get
            {
                return ((__Internal*)__Instance)->pitch;
            }

            set
            {
                ((__Internal*)__Instance)->pitch = value;
            }
        }

        public float Roll
        {
            get
            {
                return ((__Internal*)__Instance)->roll;
            }

            set
            {
                ((__Internal*)__Instance)->roll = value;
            }
        }

        public global::RocketSim.Vec ForwardVector
        {
            get
            {
                var ___ret = new global::RocketSim.Vec.__Internal();
                __Internal.GetForwardVector(__Instance, new IntPtr(&___ret));
                return global::RocketSim.Vec.__CreateInstance(___ret);
            }
        }
    }

    public unsafe partial class WheelPairConfig : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float wheelRadius;

            [FieldOffset(4)]
            internal float suspensionRestLength;

            [FieldOffset(16)]
            internal global::RocketSim.Vec.__Internal connectionPointOffset;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0WheelPairConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0WheelPairConfig@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.WheelPairConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.WheelPairConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.WheelPairConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.WheelPairConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static WheelPairConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new WheelPairConfig(native.ToPointer(), skipVTables);
        }

        internal static WheelPairConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (WheelPairConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static WheelPairConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new WheelPairConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private WheelPairConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected WheelPairConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public WheelPairConfig(global::RocketSim.WheelPairConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.WheelPairConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.WheelPairConfig.__Internal*) __Instance) = *((global::RocketSim.WheelPairConfig.__Internal*) _0.__Instance);
        }

        public WheelPairConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.WheelPairConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float WheelRadius
        {
            get
            {
                return ((__Internal*)__Instance)->wheelRadius;
            }

            set
            {
                ((__Internal*)__Instance)->wheelRadius = value;
            }
        }

        public float SuspensionRestLength
        {
            get
            {
                return ((__Internal*)__Instance)->suspensionRestLength;
            }

            set
            {
                ((__Internal*)__Instance)->suspensionRestLength = value;
            }
        }

        public global::RocketSim.Vec ConnectionPointOffset
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->connectionPointOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->connectionPointOffset = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class CarConfig : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::RocketSim.Vec.__Internal hitboxSize;

            [FieldOffset(16)]
            internal global::RocketSim.Vec.__Internal hitboxPosOffset;

            [FieldOffset(32)]
            internal global::RocketSim.WheelPairConfig.__Internal frontWheels;

            [FieldOffset(64)]
            internal global::RocketSim.WheelPairConfig.__Internal backWheels;

            [FieldOffset(96)]
            internal float dodgeDeadzone;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0CarConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0CarConfig@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.CarConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.CarConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CarConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CarConfig(native.ToPointer(), skipVTables);
        }

        internal static CarConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CarConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CarConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CarConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CarConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CarConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CarConfig(global::RocketSim.CarConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.CarConfig.__Internal*) __Instance) = *((global::RocketSim.CarConfig.__Internal*) _0.__Instance);
        }

        public CarConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::RocketSim.Vec HitboxSize
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->hitboxSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->hitboxSize = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec HitboxPosOffset
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->hitboxPosOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->hitboxPosOffset = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.WheelPairConfig FrontWheels
        {
            get
            {
                return global::RocketSim.WheelPairConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->frontWheels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->frontWheels = *(global::RocketSim.WheelPairConfig.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.WheelPairConfig BackWheels
        {
            get
            {
                return global::RocketSim.WheelPairConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->backWheels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->backWheels = *(global::RocketSim.WheelPairConfig.__Internal*) value.__Instance;
            }
        }

        public float DodgeDeadzone
        {
            get
            {
                return ((__Internal*)__Instance)->dodgeDeadzone;
            }

            set
            {
                ((__Internal*)__Instance)->dodgeDeadzone = value;
            }
        }
    }

    public unsafe partial class CarConfig
    {
        public partial struct __Internal
        {
        }

        public static global::RocketSim.CarConfig CAR_CONFIG_OCTANE
        {
            get
            {
                var __ptr = (global::RocketSim.CarConfig.__Internal*)global::RocketSim.__Symbols.RocketSim._CAR_CONFIG_OCTANE__3UCarConfig__B;
                return global::RocketSim.CarConfig.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::RocketSim.CarConfig CAR_CONFIG_DOMINUS
        {
            get
            {
                var __ptr = (global::RocketSim.CarConfig.__Internal*)global::RocketSim.__Symbols.RocketSim._CAR_CONFIG_DOMINUS__3UCarConfig__B;
                return global::RocketSim.CarConfig.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::RocketSim.CarConfig CAR_CONFIG_PLANK
        {
            get
            {
                var __ptr = (global::RocketSim.CarConfig.__Internal*)global::RocketSim.__Symbols.RocketSim._CAR_CONFIG_PLANK__3UCarConfig__B;
                return global::RocketSim.CarConfig.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::RocketSim.CarConfig CAR_CONFIG_BREAKOUT
        {
            get
            {
                var __ptr = (global::RocketSim.CarConfig.__Internal*)global::RocketSim.__Symbols.RocketSim._CAR_CONFIG_BREAKOUT__3UCarConfig__B;
                return global::RocketSim.CarConfig.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::RocketSim.CarConfig CAR_CONFIG_HYBRID
        {
            get
            {
                var __ptr = (global::RocketSim.CarConfig.__Internal*)global::RocketSim.__Symbols.RocketSim._CAR_CONFIG_HYBRID__3UCarConfig__B;
                return global::RocketSim.CarConfig.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::RocketSim.CarConfig CAR_CONFIG_MERC
        {
            get
            {
                var __ptr = (global::RocketSim.CarConfig.__Internal*)global::RocketSim.__Symbols.RocketSim._CAR_CONFIG_MERC__3UCarConfig__B;
                return global::RocketSim.CarConfig.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class CarControls : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float throttle;
            internal float steer;
            internal float pitch;
            internal float yaw;
            internal float roll;
            internal byte boost;
            internal byte jump;
            internal byte handbrake;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0CarControls@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0CarControls@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?ClampFix@CarControls@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClampFix(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarControls> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarControls>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.CarControls managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.CarControls managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CarControls __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CarControls(native.ToPointer(), skipVTables);
        }

        internal static CarControls __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CarControls)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CarControls __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CarControls(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CarControls(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CarControls(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CarControls()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarControls.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public CarControls(global::RocketSim.CarControls _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarControls.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.CarControls.__Internal*) __Instance) = *((global::RocketSim.CarControls.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void ClampFix()
        {
            __Internal.ClampFix(__Instance);
        }

        public float Throttle
        {
            get
            {
                return ((__Internal*)__Instance)->throttle;
            }

            set
            {
                ((__Internal*)__Instance)->throttle = value;
            }
        }

        public float Steer
        {
            get
            {
                return ((__Internal*)__Instance)->steer;
            }

            set
            {
                ((__Internal*)__Instance)->steer = value;
            }
        }

        public float Pitch
        {
            get
            {
                return ((__Internal*)__Instance)->pitch;
            }

            set
            {
                ((__Internal*)__Instance)->pitch = value;
            }
        }

        public float Yaw
        {
            get
            {
                return ((__Internal*)__Instance)->yaw;
            }

            set
            {
                ((__Internal*)__Instance)->yaw = value;
            }
        }

        public float Roll
        {
            get
            {
                return ((__Internal*)__Instance)->roll;
            }

            set
            {
                ((__Internal*)__Instance)->roll = value;
            }
        }

        public bool Boost
        {
            get
            {
                return ((__Internal*)__Instance)->boost != 0;
            }

            set
            {
                ((__Internal*)__Instance)->boost = (byte) (value ? 1 : 0);
            }
        }

        public bool Jump
        {
            get
            {
                return ((__Internal*)__Instance)->jump != 0;
            }

            set
            {
                ((__Internal*)__Instance)->jump = (byte) (value ? 1 : 0);
            }
        }

        public bool Handbrake
        {
            get
            {
                return ((__Internal*)__Instance)->handbrake != 0;
            }

            set
            {
                ((__Internal*)__Instance)->handbrake = (byte) (value ? 1 : 0);
            }
        }
    }

    namespace RLConst
    {
        public unsafe partial class CarSpawnPos : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 12)]
            public partial struct __Internal
            {
                internal float x;
                internal float y;
                internal float yawAng;

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0CarSpawnPos@RLConst@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.RLConst.CarSpawnPos> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.RLConst.CarSpawnPos>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.RLConst.CarSpawnPos managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.RLConst.CarSpawnPos managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static CarSpawnPos __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CarSpawnPos(native.ToPointer(), skipVTables);
            }

            internal static CarSpawnPos __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CarSpawnPos)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static CarSpawnPos __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CarSpawnPos(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CarSpawnPos(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected CarSpawnPos(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public CarSpawnPos()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.RLConst.CarSpawnPos.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public CarSpawnPos(global::RocketSim.RLConst.CarSpawnPos _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.RLConst.CarSpawnPos.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::RocketSim.RLConst.CarSpawnPos.__Internal*) __Instance) = *((global::RocketSim.RLConst.CarSpawnPos.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public float X
            {
                get
                {
                    return ((__Internal*)__Instance)->x;
                }

                set
                {
                    ((__Internal*)__Instance)->x = value;
                }
            }

            public float Y
            {
                get
                {
                    return ((__Internal*)__Instance)->y;
                }

                set
                {
                    ((__Internal*)__Instance)->y = value;
                }
            }

            public float YawAng
            {
                get
                {
                    return ((__Internal*)__Instance)->yawAng;
                }

                set
                {
                    ((__Internal*)__Instance)->yawAng = value;
                }
            }
        }

        public unsafe partial class RLConst
        {
            public partial struct __Internal
            {
            }

            public static float GRAVITY_Z { get; } = -650;

            public static float ARENA_EXTENT_X { get; } = 4096;

            public static float ARENA_EXTENT_Y { get; } = 5120;

            public static float ARENA_HEIGHT { get; } = 2048;

            public static float CAR_MASS_BT { get; } = 180.0F;

            public static float BALL_MASS_BT { get; } = 30;

            public static float CAR_COLLISION_FRICTION { get; } = 0.300000012F;

            public static float CAR_COLLISION_RESTITUTION { get; } = 0.100000001F;

            public static float CARBALL_COLLISION_FRICTION { get; } = 2.0F;

            public static float CARBALL_COLLISION_RESTITUTION { get; } = 0.0F;

            public static float CARWORLD_COLLISION_FRICTION { get; } = 0.300000012F;

            public static float CARWORLD_COLLISION_RESTITUTION { get; } = 0.300000012F;

            public static float CARCAR_COLLISION_FRICTION { get; } = 0.0900000035F;

            public static float CARCAR_COLLISION_RESTITUTION { get; } = 0.100000001F;

            public static float BALL_REST_Z { get; } = 93.1500015F;

            public static float BALL_MAX_ANG_SPEED { get; } = 6.0F;

            public static float BALL_DRAG { get; } = 0.0299999993F;

            public static float BALL_FRICTION { get; } = 0.349999994F;

            public static float BALL_RESTITUTION { get; } = 0.600000024F;

            public static float CAR_MAX_SPEED { get; } = 2300.0F;

            public static float BALL_MAX_SPEED { get; } = 6000.0F;

            public static float BOOST_MAX { get; } = 100.0F;

            public static float BOOST_USED_PER_SECOND { get; } = 33.3333321;

            public static float BOOST_MIN_TIME { get; } = 0.100000001F;

            public static float BOOST_FORCE { get; } = 3816.0F;

            public static float BOOST_SPAWN_AMOUNT { get; } = 33.3333321;

            public static float BOOST_FORCE_GROUND_DECAY_MIN_VEL { get; } = 600.0F;

            public static float BOOST_FORCE_GROUND_DECAY_AMOUNT { get; } = 0.0719999969F;

            public static float CAR_MAX_ANG_SPEED { get; } = 5.5F;

            public static float SUPERSONIC_START_SPEED { get; } = 2200.0F;

            public static float SUPERSONIC_MAINTAIN_MIN_SPEED { get; } = 2100;

            public static float SUPERSONIC_MAINTAIN_MAX_TIME { get; } = 1.0F;

            public static float POWERSLIDE_RISE_RATE { get; } = 5;

            public static float POWERSLIDE_FALL_RATE { get; } = 2;

            public static float THROTTLE_TORQUE_AMOUNT { get; } = 72000;

            public static float BRAKE_TORQUE_AMOUNT { get; } = 2625;

            public static float STOPPING_FORWARD_VEL { get; } = 25.0F;

            public static float COASTING_BRAKE_FACTOR { get; } = 0.150000006F;

            public static float THROTTLE_DEADZONE { get; } = 0.00100000005F;

            public static float THROTTLE_AIR_FORCE { get; } = 240;

            public static float JUMP_ACCEL { get; } = 1458.33337;

            public static float JUMP_IMMEDIATE_FORCE { get; } = 291.666656;

            public static float JUMP_MIN_TIME { get; } = 0.0250000004F;

            public static float JUMP_RESET_TIME_PAD { get; } = 0.0250000004;

            public static float JUMP_MAX_TIME { get; } = 0.200000003F;

            public static float DOUBLEJUMP_MAX_DELAY { get; } = 1.25F;

            public static float FLIP_Z_DAMP_120 { get; } = 0.349999994F;

            public static float FLIP_Z_DAMP_START { get; } = 0.150000006F;

            public static float FLIP_Z_DAMP_END { get; } = 0.209999993F;

            public static float FLIP_TORQUE_TIME { get; } = 0.649999976F;

            public static float FLIP_TORQUE_MIN_TIME { get; } = 0.409999996F;

            public static float FLIP_PITCHLOCK_TIME { get; } = 1.0F;

            public static float FLIP_INITIAL_VEL_SCALE { get; } = 500.0F;

            public static float FLIP_TORQUE_X { get; } = 260.0F;

            public static float FLIP_TORQUE_Y { get; } = 224.0F;

            public static float FLIP_FORWARD_IMPULSE_MAX_SPEED_SCALE { get; } = 1.0F;

            public static float FLIP_SIDE_IMPULSE_MAX_SPEED_SCALE { get; } = 1.89999998F;

            public static float FLIP_BACKWARD_IMPULSE_MAX_SPEED_SCALE { get; } = 2.5F;

            public static float FLIP_BACKWARD_IMPULSE_SCALE_X { get; } = 1.06666672;

            public static global::RocketSim.Vec CAR_AIR_CONTROL_TORQUE { get; } = new global::RocketSim.Vec(130, 95, 400, 0);

            public static global::RocketSim.Vec CAR_AIR_CONTROL_DAMPING { get; } = new global::RocketSim.Vec(30, 20, 50, 0);

            public static float BALL_COLLISION_RADIUS_NORMAL { get; } = 91.25F;

            public static float BALL_COLLISION_RADIUS_DROPSHOT { get; } = 103.599998F;

            public static float SOCCAR_GOAL_SCORE_BASE_THRESHOLD_Y { get; } = 5121.75F;

            public static float SOCCAR_BALL_SCORE_THRESHOLD_Y { get; } = 5213;

            public static float CAR_TORQUE_SCALE { get; } = 0.0958738029F;

            public static float CAR_AUTOFLIP_IMPULSE { get; } = 200;

            public static float CAR_AUTOFLIP_TORQUE { get; } = 1000;

            public static float CAR_AUTOFLIP_TIME { get; } = 0.400000006F;

            public static float CAR_AUTOFLIP_NORMZ_THRESH { get; } = 0.70710678118654757;

            public static float CAR_AUTOROLL_FORCE { get; } = 100;

            public static float CAR_AUTOROLL_TORQUE { get; } = 80;

            public static float BALL_CAR_EXTRA_IMPULSE_Z_SCALE { get; } = 0.349999994F;

            public static float BALL_CAR_EXTRA_IMPULSE_FORWARD_SCALE { get; } = 0.649999976F;

            public static float BALL_CAR_EXTRA_IMPULSE_MAXDELTAVEL_UU { get; } = 4600.0F;

            public static float CAR_SPAWN_REST_Z { get; } = 17.0F;

            public static float CAR_RESPAWN_Z { get; } = 36.0F;

            public static int CAR_SPAWN_LOCATION_AMOUNT { get; } = 5;

            public static int CAR_RESPAWN_LOCATION_AMOUNT { get; } = 4;

            public static global::RocketSim.RLConst.CarSpawnPos[] CAR_SPAWN_LOCATIONS { get; } = new global::RocketSim.RLConst.CarSpawnPos[5] { (global::RocketSim.RLConst.CarSpawnPos){-2048, (global::RocketSim.RLConst.CarSpawnPos) -2560, (global::RocketSim.RLConst.CarSpawnPos) 0.78539816339744828 * 1}, (global::RocketSim.RLConst.CarSpawnPos) {2048, (global::RocketSim.RLConst.CarSpawnPos) -2560, (global::RocketSim.RLConst.CarSpawnPos) 0.78539816339744828 * 3}, (global::RocketSim.RLConst.CarSpawnPos) {-256, (global::RocketSim.RLConst.CarSpawnPos) -3840, (global::RocketSim.RLConst.CarSpawnPos) 0.78539816339744828 * 2}, (global::RocketSim.RLConst.CarSpawnPos) {256, (global::RocketSim.RLConst.CarSpawnPos) -3840, (global::RocketSim.RLConst.CarSpawnPos) 0.78539816339744828 * 2}, (global::RocketSim.RLConst.CarSpawnPos) {0, (global::RocketSim.RLConst.CarSpawnPos) -4608, (global::RocketSim.RLConst.CarSpawnPos) 0.78539816339744828 * 2} };

            public static global::RocketSim.RLConst.CarSpawnPos[] CAR_RESPAWN_LOCATIONS { get; } = new global::RocketSim.RLConst.CarSpawnPos[4] { (global::RocketSim.RLConst.CarSpawnPos){-2304, (global::RocketSim.RLConst.CarSpawnPos) -4608, (global::RocketSim.RLConst.CarSpawnPos) 3.1415926535897931 / 2}, (global::RocketSim.RLConst.CarSpawnPos) {-2688, (global::RocketSim.RLConst.CarSpawnPos) -4608, (global::RocketSim.RLConst.CarSpawnPos) 3.1415926535897931 / 2}, (global::RocketSim.RLConst.CarSpawnPos) {2304, (global::RocketSim.RLConst.CarSpawnPos) -4608, (global::RocketSim.RLConst.CarSpawnPos) 3.1415926535897931 / 2}, (global::RocketSim.RLConst.CarSpawnPos) {2688, (global::RocketSim.RLConst.CarSpawnPos) -4608, (global::RocketSim.RLConst.CarSpawnPos) 3.1415926535897931 / 2} };

            public static float BUMP_COOLDOWN_TIME { get; } = 0.25F;

            public static float BUMP_MIN_FORWARD_DIST { get; } = 64.5F;

            public static float DEMO_RESPAWN_TIME { get; } = 3.0F;
        }

        namespace BTVehicle
        {
            public unsafe partial class RLConst
            {
                public partial struct __Internal
                {
                }

                public static float SUSPENSION_FORCE_SCALE_FRONT { get; } = 35.75;

                public static float SUSPENSION_FORCE_SCALE_BACK { get; } = 54.2649994;

                public static float SUSPENSION_STIFFNESS { get; } = 500.0F;

                public static float WHEELS_DAMPING_COMPRESSION { get; } = 25.0F;

                public static float WHEELS_DAMPING_RELAXATION { get; } = 40.0F;

                public static float MAX_SUSPENSION_TRAVEL { get; } = 12.0F;
            }
        }

        namespace BoostPads
        {
            public unsafe partial class RLConst
            {
                public partial struct __Internal
                {
                }

                public static float CYL_HEIGHT { get; } = 95;

                public static float CYL_RAD_BIG { get; } = 208;

                public static float CYL_RAD_SMALL { get; } = 144;

                public static float BOX_HEIGHT { get; } = 64;

                public static float BOX_RAD_BIG { get; } = 160;

                public static float BOX_RAD_SMALL { get; } = 120;

                public static float COOLDOWN_BIG { get; } = 10;

                public static float COOLDOWN_SMALL { get; } = 4;

                public static float BOOST_AMOUNT_BIG { get; } = 100;

                public static float BOOST_AMOUNT_SMALL { get; } = 12;

                public static int LOCS_AMOUNT_SMALL { get; } = 28;

                public static int LOCS_AMOUNT_BIG { get; } = 6;

                public static global::RocketSim.Vec[] LOCS_SMALL { get; } = new global::RocketSim.Vec[28] { (global::RocketSim.Vec){0.F, (global::RocketSim.Vec) -4240.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-1792.F, (global::RocketSim.Vec) -4184.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {1792.F, (global::RocketSim.Vec) -4184.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-940.F, (global::RocketSim.Vec) -3308.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {940.F, (global::RocketSim.Vec) -3308.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {0.F, (global::RocketSim.Vec) -2816.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-3584.F, (global::RocketSim.Vec) -2484.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {3584.F, (global::RocketSim.Vec) -2484.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-1788.F, (global::RocketSim.Vec) -2300.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {1788.F, (global::RocketSim.Vec) -2300.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-2048.F, (global::RocketSim.Vec) -1036.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {0.F, (global::RocketSim.Vec) -1024.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {2048.F, (global::RocketSim.Vec) -1036.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-1024.F, (global::RocketSim.Vec) 0.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {1024.F, (global::RocketSim.Vec) 0.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-2048.F, (global::RocketSim.Vec) 1036.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {0.F, (global::RocketSim.Vec) 1024.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {2048.F, (global::RocketSim.Vec) 1036.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-1788.F, (global::RocketSim.Vec) 2300.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {1788.F, (global::RocketSim.Vec) 2300.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-3584.F, (global::RocketSim.Vec) 2484.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {3584.F, (global::RocketSim.Vec) 2484.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {0.F, (global::RocketSim.Vec) 2816.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-940.F, (global::RocketSim.Vec) 3310.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {940.F, (global::RocketSim.Vec) 3308.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {-1792.F, (global::RocketSim.Vec) 4184.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {1792.F, (global::RocketSim.Vec) 4184.F, (global::RocketSim.Vec) 70.F}, (global::RocketSim.Vec) {0.F, (global::RocketSim.Vec) 4240.F, (global::RocketSim.Vec) 70.F} };

                public static global::RocketSim.Vec[] LOCS_BIG { get; } = new global::RocketSim.Vec[6] { (global::RocketSim.Vec){-3584.F, (global::RocketSim.Vec) 0.F, (global::RocketSim.Vec) 73.F}, (global::RocketSim.Vec) {3584.F, (global::RocketSim.Vec) 0.F, (global::RocketSim.Vec) 73.F}, (global::RocketSim.Vec) {-3072.F, (global::RocketSim.Vec) 4096.F, (global::RocketSim.Vec) 73.F}, (global::RocketSim.Vec) {3072.F, (global::RocketSim.Vec) 4096.F, (global::RocketSim.Vec) 73.F}, (global::RocketSim.Vec) {-3072.F, (global::RocketSim.Vec) -4096.F, (global::RocketSim.Vec) 73.F}, (global::RocketSim.Vec) {3072.F, (global::RocketSim.Vec) -4096.F, (global::RocketSim.Vec) 73.F} };
            }
        }
    }

    public enum Team : byte
    {
        BLUE = 0,
        ORANGE = 1
    }

    public unsafe partial class BtCompoundShape
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtCompoundShape> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtCompoundShape>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtCompoundShape managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtCompoundShape managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtCompoundShape __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtCompoundShape(native.ToPointer(), skipVTables);
        }

        internal static BtCompoundShape __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtCompoundShape)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtCompoundShape __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtCompoundShape(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtCompoundShape(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtCompoundShape(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class BtBoxShape
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtBoxShape> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtBoxShape>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtBoxShape managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtBoxShape managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtBoxShape __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtBoxShape(native.ToPointer(), skipVTables);
        }

        internal static BtBoxShape __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtBoxShape)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtBoxShape __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtBoxShape(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtBoxShape(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtBoxShape(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CarState : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 256)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::RocketSim.Vec.__Internal pos;

            [FieldOffset(16)]
            internal global::RocketSim.RotMat.__Internal rotMat;

            [FieldOffset(64)]
            internal global::RocketSim.Vec.__Internal vel;

            [FieldOffset(80)]
            internal global::RocketSim.Vec.__Internal angVel;

            [FieldOffset(96)]
            internal byte isOnGround;

            [FieldOffset(97)]
            internal byte hasJumped;

            [FieldOffset(98)]
            internal byte hasDoubleJumped;

            [FieldOffset(99)]
            internal byte hasFlipped;

            [FieldOffset(112)]
            internal global::RocketSim.Vec.__Internal lastRelDodgeTorque;

            [FieldOffset(128)]
            internal float jumpTime;

            [FieldOffset(132)]
            internal float flipTime;

            [FieldOffset(136)]
            internal byte isJumping;

            [FieldOffset(140)]
            internal float airTimeSinceJump;

            [FieldOffset(144)]
            internal float boost;

            [FieldOffset(148)]
            internal float timeSpentBoosting;

            [FieldOffset(152)]
            internal byte isSupersonic;

            [FieldOffset(156)]
            internal float supersonicTime;

            [FieldOffset(160)]
            internal float handbrakeVal;

            [FieldOffset(164)]
            internal byte isAutoFlipping;

            [FieldOffset(168)]
            internal float autoFlipTimer;

            [FieldOffset(172)]
            internal float autoFlipTorqueScale;

            [FieldOffset(176)]
            internal global::RocketSim.CarState.WorldContact.__Internal worldContact;

            [FieldOffset(208)]
            internal global::RocketSim.CarState.CarContact.__Internal carContact;

            [FieldOffset(216)]
            internal byte isDemoed;

            [FieldOffset(220)]
            internal float demoRespawnTimer;

            [FieldOffset(224)]
            internal ulong lastHitBallTick;

            [FieldOffset(232)]
            internal global::RocketSim.CarControls.__Internal lastControls;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0CarState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0CarState@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);
        }

        public unsafe partial class WorldContact : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal byte hasContact;

                [FieldOffset(16)]
                internal global::RocketSim.Vec.__Internal contactNormal;

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0<unnamed-type-worldContact>@CarState@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0<unnamed-type-worldContact>@CarState@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarState.WorldContact> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarState.WorldContact>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.CarState.WorldContact managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.CarState.WorldContact managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static WorldContact __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new WorldContact(native.ToPointer(), skipVTables);
            }

            internal static WorldContact __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (WorldContact)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static WorldContact __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new WorldContact(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private WorldContact(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected WorldContact(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public WorldContact(global::RocketSim.CarState.WorldContact __0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarState.WorldContact.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::RocketSim.CarState.WorldContact.__Internal*) __Instance) = *((global::RocketSim.CarState.WorldContact.__Internal*) __0.__Instance);
            }

            public WorldContact()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarState.WorldContact.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public bool HasContact
            {
                get
                {
                    return ((__Internal*)__Instance)->hasContact != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->hasContact = (byte) (value ? 1 : 0);
                }
            }

            public global::RocketSim.Vec ContactNormal
            {
                get
                {
                    return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->contactNormal));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->contactNormal = *(global::RocketSim.Vec.__Internal*) value.__Instance;
                }
            }
        }

        public unsafe partial class CarContact : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal uint otherCarID;
                internal float cooldownTimer;

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0<unnamed-type-carContact>@CarState@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0<unnamed-type-carContact>@CarState@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarState.CarContact> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarState.CarContact>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.CarState.CarContact managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.CarState.CarContact managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static CarContact __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CarContact(native.ToPointer(), skipVTables);
            }

            internal static CarContact __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CarContact)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static CarContact __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CarContact(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CarContact(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected CarContact(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public CarContact(global::RocketSim.CarState.CarContact __0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarState.CarContact.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::RocketSim.CarState.CarContact.__Internal*) __Instance) = *((global::RocketSim.CarState.CarContact.__Internal*) __0.__Instance);
            }

            public CarContact()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarState.CarContact.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint OtherCarID
            {
                get
                {
                    return ((__Internal*)__Instance)->otherCarID;
                }

                set
                {
                    ((__Internal*)__Instance)->otherCarID = value;
                }
            }

            public float CooldownTimer
            {
                get
                {
                    return ((__Internal*)__Instance)->cooldownTimer;
                }

                set
                {
                    ((__Internal*)__Instance)->cooldownTimer = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarState> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.CarState>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.CarState managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.CarState managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CarState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CarState(native.ToPointer(), skipVTables);
        }

        internal static CarState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CarState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CarState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CarState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CarState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CarState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CarState(global::RocketSim.CarState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.CarState.__Internal*) __Instance) = *((global::RocketSim.CarState.__Internal*) _0.__Instance);
        }

        public CarState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.CarState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::RocketSim.Vec Pos
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pos = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.RotMat RotMat
        {
            get
            {
                return global::RocketSim.RotMat.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rotMat));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rotMat = *(global::RocketSim.RotMat.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec Vel
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->vel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->vel = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec AngVel
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->angVel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->angVel = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public bool IsOnGround
        {
            get
            {
                return ((__Internal*)__Instance)->isOnGround != 0;
            }

            set
            {
                ((__Internal*)__Instance)->isOnGround = (byte) (value ? 1 : 0);
            }
        }

        public bool HasJumped
        {
            get
            {
                return ((__Internal*)__Instance)->hasJumped != 0;
            }

            set
            {
                ((__Internal*)__Instance)->hasJumped = (byte) (value ? 1 : 0);
            }
        }

        public bool HasDoubleJumped
        {
            get
            {
                return ((__Internal*)__Instance)->hasDoubleJumped != 0;
            }

            set
            {
                ((__Internal*)__Instance)->hasDoubleJumped = (byte) (value ? 1 : 0);
            }
        }

        public bool HasFlipped
        {
            get
            {
                return ((__Internal*)__Instance)->hasFlipped != 0;
            }

            set
            {
                ((__Internal*)__Instance)->hasFlipped = (byte) (value ? 1 : 0);
            }
        }

        public global::RocketSim.Vec LastRelDodgeTorque
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->lastRelDodgeTorque));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->lastRelDodgeTorque = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public float JumpTime
        {
            get
            {
                return ((__Internal*)__Instance)->jumpTime;
            }

            set
            {
                ((__Internal*)__Instance)->jumpTime = value;
            }
        }

        public float FlipTime
        {
            get
            {
                return ((__Internal*)__Instance)->flipTime;
            }

            set
            {
                ((__Internal*)__Instance)->flipTime = value;
            }
        }

        public bool IsJumping
        {
            get
            {
                return ((__Internal*)__Instance)->isJumping != 0;
            }

            set
            {
                ((__Internal*)__Instance)->isJumping = (byte) (value ? 1 : 0);
            }
        }

        public float AirTimeSinceJump
        {
            get
            {
                return ((__Internal*)__Instance)->airTimeSinceJump;
            }

            set
            {
                ((__Internal*)__Instance)->airTimeSinceJump = value;
            }
        }

        public float Boost
        {
            get
            {
                return ((__Internal*)__Instance)->boost;
            }

            set
            {
                ((__Internal*)__Instance)->boost = value;
            }
        }

        public float TimeSpentBoosting
        {
            get
            {
                return ((__Internal*)__Instance)->timeSpentBoosting;
            }

            set
            {
                ((__Internal*)__Instance)->timeSpentBoosting = value;
            }
        }

        public bool IsSupersonic
        {
            get
            {
                return ((__Internal*)__Instance)->isSupersonic != 0;
            }

            set
            {
                ((__Internal*)__Instance)->isSupersonic = (byte) (value ? 1 : 0);
            }
        }

        public float SupersonicTime
        {
            get
            {
                return ((__Internal*)__Instance)->supersonicTime;
            }

            set
            {
                ((__Internal*)__Instance)->supersonicTime = value;
            }
        }

        public float HandbrakeVal
        {
            get
            {
                return ((__Internal*)__Instance)->handbrakeVal;
            }

            set
            {
                ((__Internal*)__Instance)->handbrakeVal = value;
            }
        }

        public bool IsAutoFlipping
        {
            get
            {
                return ((__Internal*)__Instance)->isAutoFlipping != 0;
            }

            set
            {
                ((__Internal*)__Instance)->isAutoFlipping = (byte) (value ? 1 : 0);
            }
        }

        public float AutoFlipTimer
        {
            get
            {
                return ((__Internal*)__Instance)->autoFlipTimer;
            }

            set
            {
                ((__Internal*)__Instance)->autoFlipTimer = value;
            }
        }

        public float AutoFlipTorqueScale
        {
            get
            {
                return ((__Internal*)__Instance)->autoFlipTorqueScale;
            }

            set
            {
                ((__Internal*)__Instance)->autoFlipTorqueScale = value;
            }
        }

        public global::RocketSim.CarState.WorldContact worldContact
        {
            get
            {
                return global::RocketSim.CarState.WorldContact.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->worldContact));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->worldContact = *(global::RocketSim.CarState.WorldContact.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.CarState.CarContact carContact
        {
            get
            {
                return global::RocketSim.CarState.CarContact.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->carContact));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->carContact = *(global::RocketSim.CarState.CarContact.__Internal*) value.__Instance;
            }
        }

        public bool IsDemoed
        {
            get
            {
                return ((__Internal*)__Instance)->isDemoed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->isDemoed = (byte) (value ? 1 : 0);
            }
        }

        public float DemoRespawnTimer
        {
            get
            {
                return ((__Internal*)__Instance)->demoRespawnTimer;
            }

            set
            {
                ((__Internal*)__Instance)->demoRespawnTimer = value;
            }
        }

        public ulong LastHitBallTick
        {
            get
            {
                return ((__Internal*)__Instance)->lastHitBallTick;
            }

            set
            {
                ((__Internal*)__Instance)->lastHitBallTick = value;
            }
        }

        public global::RocketSim.CarControls LastControls
        {
            get
            {
                return global::RocketSim.CarControls.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->lastControls));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->lastControls = *(global::RocketSim.CarControls.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class Car : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 464)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::RocketSim.CarConfig.__Internal config;

            [FieldOffset(112)]
            internal global::RocketSim.Team team;

            [FieldOffset(116)]
            internal uint id;

            [FieldOffset(120)]
            internal global::RocketSim.CarControls.__Internal controls;

            [FieldOffset(144)]
            internal __IntPtr _bulletVehicle;

            [FieldOffset(152)]
            internal __IntPtr _bulletVehicleRaycaster;

            [FieldOffset(160)]
            internal __IntPtr _rigidBody;

            [FieldOffset(168)]
            internal __IntPtr _compoundShape;

            [FieldOffset(176)]
            internal __IntPtr _childHitboxShape;

            [FieldOffset(192)]
            internal global::RocketSim.CarState.__Internal _internalState;

            [FieldOffset(448)]
            internal global::RocketSim.Vec.__Internal _velocityImpulseCache;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??1Car@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Demolish@Car@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Demolish(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Respawn@Car@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Respawn(__IntPtr __instance, int seed);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?_PreTickUpdate@Car@@QEAAXMPEAUSuspensionCollisionGrid@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PreTickUpdate(__IntPtr __instance, float tickTime, __IntPtr grid);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?_PostTickUpdate@Car@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PostTickUpdate(__IntPtr __instance, float tickTime);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?_FinishPhysicsTick@Car@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FinishPhysicsTick(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetState@Car@@QEAA?AUCarState@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetState(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?SetState@Car@@QEAAXAEBUCarState@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetState(__IntPtr __instance, __IntPtr state);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetForwardDir@Car@@QEBA?AUVec@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetForwardDir(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetRightDir@Car@@QEBA?AUVec@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetRightDir(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetUpDir@Car@@QEBA?AUVec@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetUpDir(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?_AllocateCar@Car@@SAPEAV1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AllocateCar();
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Car> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Car>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.Car managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.Car managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Car __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Car(native.ToPointer(), skipVTables);
        }

        internal static Car __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Car)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Car __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Car(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Car(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Car(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Demolish()
        {
            __Internal.Demolish(__Instance);
        }

        public void Respawn(int seed)
        {
            __Internal.Respawn(__Instance, seed);
        }

        public void PreTickUpdate(float tickTime, global::RocketSim.SuspensionCollisionGrid grid)
        {
            var __arg1 = grid is null ? __IntPtr.Zero : grid.__Instance;
            __Internal.PreTickUpdate(__Instance, tickTime, __arg1);
        }

        public void PostTickUpdate(float tickTime)
        {
            __Internal.PostTickUpdate(__Instance, tickTime);
        }

        public void FinishPhysicsTick()
        {
            __Internal.FinishPhysicsTick(__Instance);
        }

        public global::RocketSim.CarConfig Config
        {
            get
            {
                return global::RocketSim.CarConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->config));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->config = *(global::RocketSim.CarConfig.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Team Team
        {
            get
            {
                return ((__Internal*)__Instance)->team;
            }

            set
            {
                ((__Internal*)__Instance)->team = value;
            }
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public global::RocketSim.CarControls Controls
        {
            get
            {
                return global::RocketSim.CarControls.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->controls));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->controls = *(global::RocketSim.CarControls.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.BtCompoundShape CompoundShape
        {
            get
            {
                var __result0 = global::RocketSim.BtCompoundShape.__GetOrCreateInstance(((__Internal*)__Instance)->_compoundShape, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_compoundShape = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::RocketSim.BtBoxShape ChildHitboxShape
        {
            get
            {
                var __result0 = global::RocketSim.BtBoxShape.__GetOrCreateInstance(((__Internal*)__Instance)->_childHitboxShape, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_childHitboxShape = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::RocketSim.CarState InternalState
        {
            get
            {
                return global::RocketSim.CarState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_internalState));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_internalState = *(global::RocketSim.CarState.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec VelocityImpulseCache
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_velocityImpulseCache));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_velocityImpulseCache = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.CarState State
        {
            get
            {
                var ___ret = new global::RocketSim.CarState.__Internal();
                __Internal.GetState(__Instance, new IntPtr(&___ret));
                return global::RocketSim.CarState.__CreateInstance(___ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetState(__Instance, __arg0);
            }
        }

        public global::RocketSim.Vec ForwardDir
        {
            get
            {
                var ___ret = new global::RocketSim.Vec.__Internal();
                __Internal.GetForwardDir(__Instance, new IntPtr(&___ret));
                return global::RocketSim.Vec.__CreateInstance(___ret);
            }
        }

        public global::RocketSim.Vec RightDir
        {
            get
            {
                var ___ret = new global::RocketSim.Vec.__Internal();
                __Internal.GetRightDir(__Instance, new IntPtr(&___ret));
                return global::RocketSim.Vec.__CreateInstance(___ret);
            }
        }

        public global::RocketSim.Vec UpDir
        {
            get
            {
                var ___ret = new global::RocketSim.Vec.__Internal();
                __Internal.GetUpDir(__Instance, new IntPtr(&___ret));
                return global::RocketSim.Vec.__CreateInstance(___ret);
            }
        }

        public static global::RocketSim.Car AllocateCar
        {
            get
            {
                var ___ret = __Internal.AllocateCar();
                var __result0 = global::RocketSim.Car.__GetOrCreateInstance(___ret, false);
                return __result0;
            }
        }
    }

    public unsafe partial class BtSphereShape
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtSphereShape> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtSphereShape>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtSphereShape managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtSphereShape managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtSphereShape __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtSphereShape(native.ToPointer(), skipVTables);
        }

        internal static BtSphereShape __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtSphereShape)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtSphereShape __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtSphereShape(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtSphereShape(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtSphereShape(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class BallHitInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint carID;

            [FieldOffset(16)]
            internal global::RocketSim.Vec.__Internal relativePosOnBall;

            [FieldOffset(32)]
            internal global::RocketSim.Vec.__Internal ballPos;

            [FieldOffset(48)]
            internal global::RocketSim.Vec.__Internal extraHitVel;

            [FieldOffset(64)]
            internal ulong tickCountWhenHit;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0BallHitInfo@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0BallHitInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BallHitInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BallHitInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BallHitInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BallHitInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BallHitInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BallHitInfo(native.ToPointer(), skipVTables);
        }

        internal static BallHitInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BallHitInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BallHitInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BallHitInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BallHitInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BallHitInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BallHitInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.BallHitInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public BallHitInfo(global::RocketSim.BallHitInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.BallHitInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.BallHitInfo.__Internal*) __Instance) = *((global::RocketSim.BallHitInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint CarID
        {
            get
            {
                return ((__Internal*)__Instance)->carID;
            }

            set
            {
                ((__Internal*)__Instance)->carID = value;
            }
        }

        public global::RocketSim.Vec RelativePosOnBall
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->relativePosOnBall));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->relativePosOnBall = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec BallPos
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ballPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ballPos = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec ExtraHitVel
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->extraHitVel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->extraHitVel = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public ulong TickCountWhenHit
        {
            get
            {
                return ((__Internal*)__Instance)->tickCountWhenHit;
            }

            set
            {
                ((__Internal*)__Instance)->tickCountWhenHit = value;
            }
        }
    }

    public unsafe partial class BallState : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::RocketSim.Vec.__Internal pos;

            [FieldOffset(16)]
            internal global::RocketSim.Vec.__Internal vel;

            [FieldOffset(32)]
            internal global::RocketSim.Vec.__Internal angVel;

            [FieldOffset(48)]
            internal global::RocketSim.BallHitInfo.__Internal ballHitInfo;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0BallState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0BallState@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BallState> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BallState>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BallState managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BallState managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BallState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BallState(native.ToPointer(), skipVTables);
        }

        internal static BallState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BallState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BallState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BallState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BallState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BallState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BallState(global::RocketSim.BallState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.BallState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.BallState.__Internal*) __Instance) = *((global::RocketSim.BallState.__Internal*) _0.__Instance);
        }

        public BallState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.BallState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::RocketSim.Vec Pos
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pos = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec Vel
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->vel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->vel = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Vec AngVel
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->angVel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->angVel = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.BallHitInfo BallHitInfo
        {
            get
            {
                return global::RocketSim.BallHitInfo.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ballHitInfo));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ballHitInfo = *(global::RocketSim.BallHitInfo.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class Ball : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 160)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::RocketSim.BallState.__Internal _internalState;

            [FieldOffset(128)]
            internal __IntPtr _rigidBody;

            [FieldOffset(136)]
            internal __IntPtr _collisionShape;

            [FieldOffset(144)]
            internal global::RocketSim.Vec.__Internal _velocityImpulseCache;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??1Ball@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?_FinishPhysicsTick@Ball@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FinishPhysicsTick(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetState@Ball@@QEAA?AUBallState@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetState(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?SetState@Ball@@QEAAXAEBUBallState@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetState(__IntPtr __instance, __IntPtr state);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?_AllocBall@Ball@@SAPEAV1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AllocBall();

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetRadiusBullet@Ball@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetRadiusBullet(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetRadius@Ball@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetRadius(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Ball> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Ball>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.Ball managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.Ball managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Ball __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Ball(native.ToPointer(), skipVTables);
        }

        internal static Ball __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Ball)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Ball __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Ball(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Ball(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Ball(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void FinishPhysicsTick()
        {
            __Internal.FinishPhysicsTick(__Instance);
        }

        public global::RocketSim.BallState InternalState
        {
            get
            {
                return global::RocketSim.BallState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_internalState));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_internalState = *(global::RocketSim.BallState.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.BtSphereShape CollisionShape
        {
            get
            {
                var __result0 = global::RocketSim.BtSphereShape.__GetOrCreateInstance(((__Internal*)__Instance)->_collisionShape, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_collisionShape = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::RocketSim.Vec VelocityImpulseCache
        {
            get
            {
                return global::RocketSim.Vec.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_velocityImpulseCache));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_velocityImpulseCache = *(global::RocketSim.Vec.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.BallState State
        {
            get
            {
                var ___ret = new global::RocketSim.BallState.__Internal();
                __Internal.GetState(__Instance, new IntPtr(&___ret));
                return global::RocketSim.BallState.__CreateInstance(___ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetState(__Instance, __arg0);
            }
        }

        public static global::RocketSim.Ball AllocBall
        {
            get
            {
                var ___ret = __Internal.AllocBall();
                var __result0 = global::RocketSim.Ball.__GetOrCreateInstance(___ret, false);
                return __result0;
            }
        }

        public float RadiusBullet
        {
            get
            {
                var ___ret = __Internal.GetRadiusBullet(__Instance);
                return ___ret;
            }
        }

        public float Radius
        {
            get
            {
                var ___ret = __Internal.GetRadius(__Instance);
                return ___ret;
            }
        }
    }

    public unsafe partial class SuspensionCollisionGrid : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_SuspensionCollisionGrid_S_Cell___N_std_S_allocator__S0_ cellData;
            internal __IntPtr defaultWorldCollisionRB;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0SuspensionCollisionGrid@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0SuspensionCollisionGrid@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??1SuspensionCollisionGrid@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Allocate@SuspensionCollisionGrid@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Allocate(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Get@SuspensionCollisionGrid@@QEAAAEAUCell@1@HHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get(__IntPtr __instance, int i, int j, int k);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetCellMin@SuspensionCollisionGrid@@QEAA?AUVec@@HHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetCellMin(__IntPtr __instance, __IntPtr @return, int xIndex, int yIndex, int zIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetCellIndicesFromPos@SuspensionCollisionGrid@@QEAAXUVec@@AEAH11@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetCellIndicesFromPos(__IntPtr __instance, __IntPtr pos, int* i, int* j, int* k);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetCellFromPos@SuspensionCollisionGrid@@QEAAAEAUCell@1@UVec@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetCellFromPos(__IntPtr __instance, __IntPtr pos);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?UpdateDynamicCollisions@SuspensionCollisionGrid@@QEAAXUVec@@0_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UpdateDynamicCollisions(__IntPtr __instance, __IntPtr minBT, __IntPtr maxBT, bool remove);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetCellSize@SuspensionCollisionGrid@@QEAA?AUVec@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetCellSize(__IntPtr __instance, __IntPtr @return);
        }

        public unsafe partial class Cell : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal byte worldCollision;
                internal int dynamicObjects;

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0Cell@SuspensionCollisionGrid@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0Cell@SuspensionCollisionGrid@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.SuspensionCollisionGrid.Cell> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.SuspensionCollisionGrid.Cell>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.SuspensionCollisionGrid.Cell managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.SuspensionCollisionGrid.Cell managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Cell __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Cell(native.ToPointer(), skipVTables);
            }

            internal static Cell __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Cell)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Cell __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Cell(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Cell(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Cell(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Cell()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.SuspensionCollisionGrid.Cell.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public Cell(global::RocketSim.SuspensionCollisionGrid.Cell _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.SuspensionCollisionGrid.Cell.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::RocketSim.SuspensionCollisionGrid.Cell.__Internal*) __Instance) = *((global::RocketSim.SuspensionCollisionGrid.Cell.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public bool WorldCollision
            {
                get
                {
                    return ((__Internal*)__Instance)->worldCollision != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->worldCollision = (byte) (value ? 1 : 0);
                }
            }

            public int DynamicObjects
            {
                get
                {
                    return ((__Internal*)__Instance)->dynamicObjects;
                }

                set
                {
                    ((__Internal*)__Instance)->dynamicObjects = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.SuspensionCollisionGrid> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.SuspensionCollisionGrid>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.SuspensionCollisionGrid managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.SuspensionCollisionGrid managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SuspensionCollisionGrid __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SuspensionCollisionGrid(native.ToPointer(), skipVTables);
        }

        internal static SuspensionCollisionGrid __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SuspensionCollisionGrid)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SuspensionCollisionGrid __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SuspensionCollisionGrid(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::RocketSim.SuspensionCollisionGrid.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private SuspensionCollisionGrid(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SuspensionCollisionGrid(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SuspensionCollisionGrid(global::RocketSim.SuspensionCollisionGrid _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.SuspensionCollisionGrid.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public SuspensionCollisionGrid()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.SuspensionCollisionGrid.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Allocate()
        {
            __Internal.Allocate(__Instance);
        }

        public global::RocketSim.SuspensionCollisionGrid.Cell Get(int i, int j, int k)
        {
            var ___ret = __Internal.Get(__Instance, i, j, k);
            var __result0 = global::RocketSim.SuspensionCollisionGrid.Cell.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public global::RocketSim.Vec GetCellMin(int xIndex, int yIndex, int zIndex)
        {
            var ___ret = new global::RocketSim.Vec.__Internal();
            __Internal.GetCellMin(__Instance, new IntPtr(&___ret), xIndex, yIndex, zIndex);
            return global::RocketSim.Vec.__CreateInstance(___ret);
        }

        public void GetCellIndicesFromPos(global::RocketSim.Vec pos, ref int i, ref int j, ref int k)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            fixed (int* __i1 = &i)
            {
                var __arg1 = __i1;
                fixed (int* __j2 = &j)
                {
                    var __arg2 = __j2;
                    fixed (int* __k3 = &k)
                    {
                        var __arg3 = __k3;
                        __Internal.GetCellIndicesFromPos(__Instance, __arg0, __arg1, __arg2, __arg3);
                    }
                }
            }
        }

        public global::RocketSim.SuspensionCollisionGrid.Cell GetCellFromPos(global::RocketSim.Vec pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            var ___ret = __Internal.GetCellFromPos(__Instance, __arg0);
            var __result0 = global::RocketSim.SuspensionCollisionGrid.Cell.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public void UpdateDynamicCollisions(global::RocketSim.Vec minBT, global::RocketSim.Vec maxBT, bool remove)
        {
            if (ReferenceEquals(minBT, null))
                throw new global::System.ArgumentNullException("minBT", "Cannot be null because it is passed by value.");
            var __arg0 = minBT.__Instance;
            if (ReferenceEquals(maxBT, null))
                throw new global::System.ArgumentNullException("maxBT", "Cannot be null because it is passed by value.");
            var __arg1 = maxBT.__Instance;
            __Internal.UpdateDynamicCollisions(__Instance, __arg0, __arg1, remove);
        }

        public static float EXTENT_X { get; } = ARENA_EXTENT_X;

        public static float EXTENT_Y { get; } = 7680;

        public static float HEIGHT { get; } = ARENA_HEIGHT;

        public static int CELL_AMOUNT_X { get; } = 128;

        public static int CELL_AMOUNT_Y { get; } = 224;

        public static int CELL_AMOUNT_Z { get; } = 32;

        public static int CELL_AMOUNT_TOTAL { get; } = 917504;

        public static float CELL_SIZE_X { get; } = 64;

        public static float CELL_SIZE_Y { get; } = 68.5714263;

        public static float CELL_SIZE_Z { get; } = 64;

        public global::RocketSim.Vec CellSize
        {
            get
            {
                var ___ret = new global::RocketSim.Vec.__Internal();
                __Internal.GetCellSize(__Instance, new IntPtr(&___ret));
                return global::RocketSim.Vec.__CreateInstance(___ret);
            }
        }
    }

    public enum GameMode : byte
    {
        SOCCAR = 0,
        THE_VOID = 1
    }

    public unsafe partial class BtDiscreteDynamicsWorld
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtDiscreteDynamicsWorld> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtDiscreteDynamicsWorld>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtDiscreteDynamicsWorld managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtDiscreteDynamicsWorld managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtDiscreteDynamicsWorld __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtDiscreteDynamicsWorld(native.ToPointer(), skipVTables);
        }

        internal static BtDiscreteDynamicsWorld __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtDiscreteDynamicsWorld)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtDiscreteDynamicsWorld __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtDiscreteDynamicsWorld(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtDiscreteDynamicsWorld(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtDiscreteDynamicsWorld(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class BtCollisionConfiguration
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtCollisionConfiguration> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtCollisionConfiguration>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtCollisionConfiguration managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtCollisionConfiguration managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtCollisionConfiguration __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtCollisionConfiguration(native.ToPointer(), skipVTables);
        }

        internal static BtCollisionConfiguration __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtCollisionConfiguration)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtCollisionConfiguration __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtCollisionConfiguration(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtCollisionConfiguration(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtCollisionConfiguration(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class BtCollisionDispatcher
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtCollisionDispatcher> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtCollisionDispatcher>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtCollisionDispatcher managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtCollisionDispatcher managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtCollisionDispatcher __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtCollisionDispatcher(native.ToPointer(), skipVTables);
        }

        internal static BtCollisionDispatcher __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtCollisionDispatcher)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtCollisionDispatcher __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtCollisionDispatcher(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtCollisionDispatcher(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtCollisionDispatcher(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class BtDbvtBroadphase
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtDbvtBroadphase> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtDbvtBroadphase>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtDbvtBroadphase managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtDbvtBroadphase managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtDbvtBroadphase __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtDbvtBroadphase(native.ToPointer(), skipVTables);
        }

        internal static BtDbvtBroadphase __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtDbvtBroadphase)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtDbvtBroadphase __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtDbvtBroadphase(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtDbvtBroadphase(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtDbvtBroadphase(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class BtSequentialImpulseConstraintSolver
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtSequentialImpulseConstraintSolver> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtSequentialImpulseConstraintSolver>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtSequentialImpulseConstraintSolver managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtSequentialImpulseConstraintSolver managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtSequentialImpulseConstraintSolver __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtSequentialImpulseConstraintSolver(native.ToPointer(), skipVTables);
        }

        internal static BtSequentialImpulseConstraintSolver __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtSequentialImpulseConstraintSolver)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtSequentialImpulseConstraintSolver __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtSequentialImpulseConstraintSolver(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtSequentialImpulseConstraintSolver(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtSequentialImpulseConstraintSolver(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class BtManifoldPoint
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtManifoldPoint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtManifoldPoint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtManifoldPoint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtManifoldPoint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtManifoldPoint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtManifoldPoint(native.ToPointer(), skipVTables);
        }

        internal static BtManifoldPoint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtManifoldPoint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtManifoldPoint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtManifoldPoint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtManifoldPoint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtManifoldPoint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class BtCollisionObjectWrapper
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtCollisionObjectWrapper> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BtCollisionObjectWrapper>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BtCollisionObjectWrapper managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BtCollisionObjectWrapper managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BtCollisionObjectWrapper __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BtCollisionObjectWrapper(native.ToPointer(), skipVTables);
        }

        internal static BtCollisionObjectWrapper __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BtCollisionObjectWrapper)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BtCollisionObjectWrapper __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BtCollisionObjectWrapper(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BtCollisionObjectWrapper(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BtCollisionObjectWrapper(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class Arena : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 912)]
        public partial struct __Internal
        {
            internal global::RocketSim.GameMode gameMode;
            internal uint _lastCarID;
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_Car___N_std_S_allocator__S0_ _cars;
            internal __IntPtr ball;
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_BoostPad___N_std_S_allocator__S0_ _boostPads;
            internal global::RocketSim.BoostPadGrid.__Internal _boostPadGrid;
            internal global::RocketSim.SuspensionCollisionGrid.__Internal _suspColGrid;
            internal float tickTime;
            internal ulong tickCount;
            internal __IntPtr _bulletWorld;
            internal global::RocketSim.Arena.BulletWorldParams.__Internal _bulletWorldParams;
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_btRigidBody___N_std_S_allocator__S0_ _worldCollisionRBs;
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_btCollisionShape___N_std_S_allocator__S0_ _worldCollisionShapes;
            internal global::RocketSim.Arena.GoalScoreCallback.__Internal _goalScoreCallback;

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??1Arena@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?AddCar@Arena@@QEAAPEAVCar@@W4Team@@AEBUCarConfig@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AddCar(__IntPtr __instance, global::RocketSim.Team team, __IntPtr config);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?RemoveCar@Arena@@QEAA_NPEAVCar@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveCar(__IntPtr __instance, __IntPtr car);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetCarFromID@Arena@@QEAAPEAVCar@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetCarFromID(__IntPtr __instance, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Create@Arena@@SAPEAV1@W4GameMode@@M@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Create(global::RocketSim.GameMode gameMode, float tickRate);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Clone@Arena@@QEAAPEAV1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Clone(__IntPtr __instance, bool copyCallbacks);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?Step@Arena@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Step(__IntPtr __instance, int ticksToSimulate);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?ResetToRandomKickoff@Arena@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ResetToRandomKickoff(__IntPtr __instance, int seed);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?_SetupArenaCollisionShapes@Arena@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetupArenaCollisionShapes(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?GetTickRate@Arena@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetTickRate(__IntPtr __instance);
        }

        public unsafe partial class BulletWorldParams : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal __IntPtr collisionConfig;
                internal __IntPtr collisionDispatcher;
                internal __IntPtr overlappingPairCache;
                internal __IntPtr constraintSolver;

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0<unnamed-type-_bulletWorldParams>@Arena@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Arena.BulletWorldParams> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Arena.BulletWorldParams>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.Arena.BulletWorldParams managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.Arena.BulletWorldParams managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BulletWorldParams __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BulletWorldParams(native.ToPointer(), skipVTables);
            }

            internal static BulletWorldParams __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BulletWorldParams)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BulletWorldParams __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BulletWorldParams(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BulletWorldParams(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BulletWorldParams(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public BulletWorldParams()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Arena.BulletWorldParams.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public BulletWorldParams(global::RocketSim.Arena.BulletWorldParams __0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Arena.BulletWorldParams.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::RocketSim.Arena.BulletWorldParams.__Internal*) __Instance) = *((global::RocketSim.Arena.BulletWorldParams.__Internal*) __0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::RocketSim.BtCollisionConfiguration CollisionConfig
            {
                get
                {
                    var __result0 = global::RocketSim.BtCollisionConfiguration.__GetOrCreateInstance(((__Internal*)__Instance)->collisionConfig, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->collisionConfig = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public global::RocketSim.BtCollisionDispatcher CollisionDispatcher
            {
                get
                {
                    var __result0 = global::RocketSim.BtCollisionDispatcher.__GetOrCreateInstance(((__Internal*)__Instance)->collisionDispatcher, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->collisionDispatcher = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public global::RocketSim.BtDbvtBroadphase OverlappingPairCache
            {
                get
                {
                    var __result0 = global::RocketSim.BtDbvtBroadphase.__GetOrCreateInstance(((__Internal*)__Instance)->overlappingPairCache, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->overlappingPairCache = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public global::RocketSim.BtSequentialImpulseConstraintSolver ConstraintSolver
            {
                get
                {
                    var __result0 = global::RocketSim.BtSequentialImpulseConstraintSolver.__GetOrCreateInstance(((__Internal*)__Instance)->constraintSolver, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->constraintSolver = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class GoalScoreCallback : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public partial struct __Internal
            {
                internal global::Std.Function.__Internal func;
                internal __IntPtr userInfo;

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0<unnamed-type-_goalScoreCallback>@Arena@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0<unnamed-type-_goalScoreCallback>@Arena@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??1<unnamed-type-_goalScoreCallback>@Arena@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Arena.GoalScoreCallback> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Arena.GoalScoreCallback>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.Arena.GoalScoreCallback managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.Arena.GoalScoreCallback managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GoalScoreCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GoalScoreCallback(native.ToPointer(), skipVTables);
            }

            internal static GoalScoreCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GoalScoreCallback)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GoalScoreCallback __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GoalScoreCallback(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::RocketSim.Arena.GoalScoreCallback.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private GoalScoreCallback(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GoalScoreCallback(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GoalScoreCallback(global::RocketSim.Arena.GoalScoreCallback __0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Arena.GoalScoreCallback.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(__0, null))
                    throw new global::System.ArgumentNullException("__0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public GoalScoreCallback()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.Arena.GoalScoreCallback.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public __IntPtr UserInfo
            {
                get
                {
                    return ((__Internal*)__Instance)->userInfo;
                }

                set
                {
                    ((__Internal*)__Instance)->userInfo = (__IntPtr) value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Arena> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.Arena>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.Arena managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.Arena managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Arena __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Arena(native.ToPointer(), skipVTables);
        }

        internal static Arena __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Arena)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Arena __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Arena(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Arena(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Arena(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::RocketSim.Car AddCar(global::RocketSim.Team team, global::RocketSim.CarConfig config)
        {
            if (ReferenceEquals(config, null))
                throw new global::System.ArgumentNullException("config", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = config.__Instance;
            var ___ret = __Internal.AddCar(__Instance, team, __arg1);
            var __result0 = global::RocketSim.Car.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public bool RemoveCar(global::RocketSim.Car car)
        {
            var __arg0 = car is null ? __IntPtr.Zero : car.__Instance;
            var ___ret = __Internal.RemoveCar(__Instance, __arg0);
            return ___ret;
        }

        public global::RocketSim.Car GetCarFromID(uint id)
        {
            var ___ret = __Internal.GetCarFromID(__Instance, id);
            var __result0 = global::RocketSim.Car.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public global::RocketSim.Arena Clone(bool copyCallbacks)
        {
            var ___ret = __Internal.Clone(__Instance, copyCallbacks);
            var __result0 = global::RocketSim.Arena.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public void Step(int ticksToSimulate)
        {
            __Internal.Step(__Instance, ticksToSimulate);
        }

        public void ResetToRandomKickoff(int seed)
        {
            __Internal.ResetToRandomKickoff(__Instance, seed);
        }

        public void SetupArenaCollisionShapes()
        {
            __Internal.SetupArenaCollisionShapes(__Instance);
        }

        public static global::RocketSim.Arena Create(global::RocketSim.GameMode gameMode, float tickRate)
        {
            var ___ret = __Internal.Create(gameMode, tickRate);
            var __result0 = global::RocketSim.Arena.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public global::RocketSim.GameMode GameMode
        {
            get
            {
                return ((__Internal*)__Instance)->gameMode;
            }

            set
            {
                ((__Internal*)__Instance)->gameMode = value;
            }
        }

        public uint LastCarID
        {
            get
            {
                return ((__Internal*)__Instance)->_lastCarID;
            }

            set
            {
                ((__Internal*)__Instance)->_lastCarID = value;
            }
        }

        public global::RocketSim.Ball Ball
        {
            get
            {
                var __result0 = global::RocketSim.Ball.__GetOrCreateInstance(((__Internal*)__Instance)->ball, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ball = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::RocketSim.BoostPadGrid BoostPadGrid
        {
            get
            {
                return global::RocketSim.BoostPadGrid.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_boostPadGrid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_boostPadGrid = *(global::RocketSim.BoostPadGrid.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.SuspensionCollisionGrid SuspColGrid
        {
            get
            {
                return global::RocketSim.SuspensionCollisionGrid.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_suspColGrid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_suspColGrid = *(global::RocketSim.SuspensionCollisionGrid.__Internal*) value.__Instance;
            }
        }

        public float TickTime
        {
            get
            {
                return ((__Internal*)__Instance)->tickTime;
            }

            set
            {
                ((__Internal*)__Instance)->tickTime = value;
            }
        }

        public ulong TickCount
        {
            get
            {
                return ((__Internal*)__Instance)->tickCount;
            }

            set
            {
                ((__Internal*)__Instance)->tickCount = value;
            }
        }

        public global::RocketSim.BtDiscreteDynamicsWorld BulletWorld
        {
            get
            {
                var __result0 = global::RocketSim.BtDiscreteDynamicsWorld.__GetOrCreateInstance(((__Internal*)__Instance)->_bulletWorld, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_bulletWorld = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::RocketSim.Arena.BulletWorldParams _bulletWorldParams
        {
            get
            {
                return global::RocketSim.Arena.BulletWorldParams.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_bulletWorldParams));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_bulletWorldParams = *(global::RocketSim.Arena.BulletWorldParams.__Internal*) value.__Instance;
            }
        }

        public global::RocketSim.Arena.GoalScoreCallback _goalScoreCallback
        {
            get
            {
                return global::RocketSim.Arena.GoalScoreCallback.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_goalScoreCallback));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_goalScoreCallback = *(global::RocketSim.Arena.GoalScoreCallback.__Internal*) value.__Instance;
            }
        }

        public float TickRate
        {
            get
            {
                var ___ret = __Internal.GetTickRate(__Instance);
                return ___ret;
            }
        }
    }

    public unsafe partial class BoostPadGrid : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 640)]
        public partial struct __Internal
        {
            internal fixed long pads[80];

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0BoostPadGrid@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "??0BoostPadGrid@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("RocketSim", EntryPoint = "?CheckCollision@BoostPadGrid@@QEAAXPEAVCar@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CheckCollision(__IntPtr __instance, __IntPtr car);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BoostPadGrid> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RocketSim.BoostPadGrid>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::RocketSim.BoostPadGrid managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::RocketSim.BoostPadGrid managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BoostPadGrid __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BoostPadGrid(native.ToPointer(), skipVTables);
        }

        internal static BoostPadGrid __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BoostPadGrid)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BoostPadGrid __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BoostPadGrid(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BoostPadGrid(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BoostPadGrid(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BoostPadGrid()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.BoostPadGrid.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public BoostPadGrid(global::RocketSim.BoostPadGrid _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RocketSim.BoostPadGrid.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::RocketSim.BoostPadGrid.__Internal*) __Instance) = *((global::RocketSim.BoostPadGrid.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void CheckCollision(global::RocketSim.Car car)
        {
            var __arg0 = car is null ? __IntPtr.Zero : car.__Instance;
            __Internal.CheckCollision(__Instance, __arg0);
        }

        public static float EXTENT_X { get; } = 4096.0F;

        public static float EXTENT_Y { get; } = 5120.0F;

        public static float EXTENT_Z { get; } = 345;

        public static int CELLS_X { get; } = 8;

        public static int CELLS_Y { get; } = 10;

        public static int CELL_SIZE_X { get; } = 1024;

        public static int CELL_SIZE_Y { get; } = 1024;

        public static int CELL_AMOUNT { get; } = 80;
    }
}

namespace RocketSim.__Symbols
{
    internal class RocketSim
    {
        public static IntPtr _CAR_CONFIG_OCTANE__3UCarConfig__B { get; }
        public static IntPtr _CAR_CONFIG_DOMINUS__3UCarConfig__B { get; }
        public static IntPtr _CAR_CONFIG_PLANK__3UCarConfig__B { get; }
        public static IntPtr _CAR_CONFIG_BREAKOUT__3UCarConfig__B { get; }
        public static IntPtr _CAR_CONFIG_HYBRID__3UCarConfig__B { get; }
        public static IntPtr _CAR_CONFIG_MERC__3UCarConfig__B { get; }
        static RocketSim()
        {
            var path = "RocketSim";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _CAR_CONFIG_OCTANE__3UCarConfig__B = CppSharp.SymbolResolver.ResolveSymbol(image, "?CAR_CONFIG_OCTANE@@3UCarConfig@@B");
            _CAR_CONFIG_DOMINUS__3UCarConfig__B = CppSharp.SymbolResolver.ResolveSymbol(image, "?CAR_CONFIG_DOMINUS@@3UCarConfig@@B");
            _CAR_CONFIG_PLANK__3UCarConfig__B = CppSharp.SymbolResolver.ResolveSymbol(image, "?CAR_CONFIG_PLANK@@3UCarConfig@@B");
            _CAR_CONFIG_BREAKOUT__3UCarConfig__B = CppSharp.SymbolResolver.ResolveSymbol(image, "?CAR_CONFIG_BREAKOUT@@3UCarConfig@@B");
            _CAR_CONFIG_HYBRID__3UCarConfig__B = CppSharp.SymbolResolver.ResolveSymbol(image, "?CAR_CONFIG_HYBRID@@3UCarConfig@@B");
            _CAR_CONFIG_MERC__3UCarConfig__B = CppSharp.SymbolResolver.ResolveSymbol(image, "?CAR_CONFIG_MERC@@3UCarConfig@@B");
        }
    }
}

namespace Std
{
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____S_btCollisionShape___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____S_btRigidBody___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____S_BoostPad___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____S_Car___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____S_SuspensionCollisionGrid_S_Cell___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }
    }

}
namespace Std
{
    namespace Vector
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector_____S_btCollisionShape___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____S_btCollisionShape___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector_____S_btRigidBody___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____S_btRigidBody___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector_____S_BoostPad___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____S_BoostPad___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector_____S_Car___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____S_Car___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____S_SuspensionCollisionGrid_S_Cell___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____S_SuspensionCollisionGrid_S_Cell___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }
    }
}
